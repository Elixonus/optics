<!DOCTYPE HTML>
<html>
    <head>
        <title>Laser Simulation</title>
        <script src="./lodash.js"></script>
    </head>
    
    <body onresize="resize();">
        <canvas id="canvas" width="1920" height="1080"></canvas>

        <style>

            body
            {
                background-color: #000000;
                overflow: hidden;
                margin: 0;
                padding: 0;
            }

            #canvas
            {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            
        </style>
        
        <script>

            class Point
            {
                constructor(x, y)
                {
                    this.x = x;
                    this.y = y;
                }

                addTo(p)
                {
                    this.x += p.x;
                    this.y += p.y;
                }

                addToPolar(r, a)
                {
                    this.x += r * Math.cos(a);
                    this.y += r * Math.sin(a);
                }

                subtractTo(p)
                {
                    this.x -= p.x;
                    this.y -= p.y;
                }

                rotateAroundPoint(p, rotation)
                {
                    let cosine = Math.cos(rotation);
                    let sine = Math.sin(rotation);
                    let xD = this.x - p.x;
                    let yD = this.y - p.y;
                    this.x = cosine * xD - sine * yD + p.x;
                    this.y = sine * xD + cosine * yD + p.y;
                }

                interpolateToPoint(p, t)
                {
                    this.x = interpolateLinear(this.x, p.x, t);
                    this.y = interpolateLinear(this.y, p.y, t);
                }
            }

            class Line
            {
                constructor(p1, p2)
                {
                    this.p1 = p1;
                    this.p2 = p2;
                }

                addTo(p)
                {
                    this.p1.addTo(p);
                    this.p2.addTo(p);
                }

                subtractTo(p)
                {
                    this.p1.subtractTo(p);
                    this.p2.subtractTo(p);
                }

                rotateAroundPoint(p, rotation)
                {
                    this.p1.rotateAroundPoint(p, rotation);
                    this.p2.rotateAroundPoint(p, rotation);
                }

                getAngle()
                {
                    let newPoint = _.cloneDeep(this.p1);
                    newPoint.subtractTo(this.p2);
                    return Math.atan2(newPoint.y, newPoint.x);
                }
            }

            class Circle
            {
                constructor(position, radius)
                {
                    this.position = position;
                    this.radius = radius;
                }
            }

            class MirrorCollection
            {
                constructor(mirrors)
                {
                    this.mirrors = mirrors;
                }

                laser(laserBeam, intersections = [], sideIgnore = null)
                {
                    if(intersections.length === LASER_MAX_BOUNCES + 1)
                    {
                        return intersections;
                    }

                    let laserLine = new Line(laserBeam.position, new Point(laserBeam.position.x + LASER_RANGE * Math.cos(laserBeam.rotation), laserBeam.position.y + LASER_RANGE * Math.sin(laserBeam.rotation)));
                    let closestIntersection;
                    let closestMirror;
                    let closestMirrorSide;
                    let distanceToClosestIntersection;

                    for(var n = 0; n < this.mirrors.length; n++)
                    {
                        let mirror = this.mirrors[n];

                        for(var m = 0; m < mirror.vertices.length; m++)
                        {
                            let mirrorSide = mirror.getSideAbsolute(m);

                            if(_.isEqual(mirrorSide, sideIgnore))
                            {
                                continue;
                            }

                            if(intersectSegmentSegment(laserLine, mirrorSide))
                            {
                                let intersection = intersectionLineLine(laserLine, mirrorSide);
                                let distanceToIntersection = distance(laserBeam.position, intersection);

                                if((closestIntersection === undefined || distanceToIntersection < distanceToClosestIntersection))
                                {
                                    closestIntersection = intersection;
                                    closestMirror = mirror;
                                    closestMirrorSide = mirrorSide;
                                    distanceToClosestIntersection = distanceToIntersection;
                                }
                            }
                        }
                    }

                    if(closestIntersection === undefined)
                    {
                        let newPoint = _.cloneDeep(laserBeam.position);
                        newPoint.addToPolar(LASER_RANGE, laserBeam.rotation);
                        intersections.push(newPoint);
                        return intersections;
                    }

                    let newIntersections = _.cloneDeep(intersections);
                    newIntersections.push(closestIntersection);

                    // angle of incidence code start
                    let angleOfIncidence = Math.PI / 2 + laserBeam.rotation - closestMirrorSide.getAngle();

                    while(angleOfIncidence > Math.PI)
                    {
                        angleOfIncidence -= Math.PI;
                    }

                    while(angleOfIncidence < 0)
                    {
                        angleOfIncidence += Math.PI;
                    }

                    if(angleOfIncidence > Math.PI / 2)
                    {
                        angleOfIncidence = Math.PI - angleOfIncidence;
                    }

                    angleOfIncidence = angleOfIncidence;

                    console.log(angleOfIncidence * 180 / Math.PI);

                    // angle of incidence code end

                    if(closestMirror.reflecting)
                    {
                        return this.laser(new Laser(closestIntersection, 2 * closestMirrorSide.getAngle() - laserBeam.rotation), newIntersections, _.cloneDeep(closestMirrorSide));
                    }

                    else
                    {
                        intersections.push(closestIntersection);
                        return intersections;
                    }
                }
            }

            class Mirror
            {
                constructor(position, rotation, vertices = [])
                {
                    this.reflecting = true;
                    this.position = position;
                    this.rotation = rotation;
                    this.vertices = vertices;
                }

                getSide(sideNumber)
                {
                    return new Line(this.vertices[sideNumber % this.vertices.length], this.vertices[(sideNumber + 1) % this.vertices.length]);
                }

                getSideAbsolute(sideNumber)
                {
                    let absoluteSide = _.cloneDeep(this.getSide(sideNumber));
                    absoluteSide.rotateAroundPoint(pointOrigin, this.rotation);
                    absoluteSide.addTo(this.position);
                    return absoluteSide;
                }

                subdivide(vertexMultiplier = 2)
                {
                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let side = this.getSide(n);
                        let interpolations = [];

                        for(var m = 1; m < vertexMultiplier; m++)
                        {
                            this.vertices.splice(n + 1, 0, interpolatePointToPoint(side.p1, side.p2, m / (vertexMultiplier + 1)));
                            n++;
                        }
                    }
                }

                makeRectangle(width, height)
                {
                    let halfWidth = width / 2;
                    let halfHeight = height / 2;
                    let topLeftCorner = new Point(-halfWidth, -halfHeight);
                    let topRightCorner = new Point(halfWidth, -halfHeight);
                    let bottomRightCorner = new Point(halfWidth, halfHeight);
                    let bottomLeftCorner = new Point(-halfWidth, halfHeight);
                    this.vertices = [topLeftCorner, topRightCorner, bottomRightCorner, bottomLeftCorner];
                }
            }

            class Laser
            {
                constructor(position, rotation, hue = 0)
                {
                    this.position = position;
                    this.rotation = rotation;
                    this.hue = hue;
                }
            }

            CanvasRenderingContext2D.prototype.reset = function()
            {
                this.direction = "ltr";
                this.fillStyle = "#000000";
                this.filter = "none";
                this.font = "10px sans-serif";
                this.globalAlpha = 1;
                this.globalCompositeOperation = "source-over";
                this.imageSmoothingEnabled = true;
                this.imageSmoothingQuality = "low";
                this.lineCap = "butt";
                this.lineDashOffset = 0;
                this.lineJoin = "miter";
                this.lineWidth = 1;
                this.miterLimit = 10;
                this.shadowBlur = 0;
                this.shadowColor = "rgba(0, 0, 0, 0)";
                this.shadowOffsetX = 0;
                this.shadowOffsetY = 0;
                this.strokeStyle = "#000000";
                this.textAlign = "start";
                this.textBaseline = "alphabetic";
            }

            var request;
            const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
            const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
            const canvas = document.getElementById("canvas");
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const ctx = canvas.getContext("2d");
            const pointOrigin = new Point(0, 0);
            const keysPressed = [];
            const LASER_MAX_BOUNCES = 10;
            const LASER_RANGE = 10000;
            var mirror = new Mirror(new Point(400, 800), 0);
            mirror.makeRectangle(100, 200);
            var mirror2 = new Mirror(new Point(700, 700), 0);
            mirror2.makeRectangle(300, 100);
            var mirror3 = new Mirror(new Point(1500, 800), 45, [new Point(-200, 0), new Point(200, 0), new Point(0, 200)]);
            var mirror4 = new Mirror(new Point(canvasWidth / 2, canvasHeight / 2), 0);
            mirror4.makeRectangle(canvasWidth, canvasHeight);
            mirror4.reflecting = false;
            var mirrorCollection = new MirrorCollection([mirror, mirror2, mirror3]);
            var lasers = [];
            lasers.push(new Laser(new Point(400, 650), 15 * Math.PI / 180, 120));

            function render()
            {
                if(keysPressed.includes("ArrowLeft"))
                {
                    lasers[0].position.x -= 2;
                }

                if(keysPressed.includes("ArrowRight"))
                {
                    lasers[0].position.x += 2;
                }

                if(keysPressed.includes("ArrowUp"))
                {
                    lasers[0].position.y -= 2;
                }

                if(keysPressed.includes("ArrowDown"))
                {
                    lasers[0].position.y += 2;
                }

                if(keysPressed.includes("a"))
                {
                    lasers[0].rotation -= 0.02;
                }

                if(keysPressed.includes("d"))
                {
                    lasers[0].rotation += 0.02;
                }
                
                ctx.reset();
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                mirrorCollection.mirrors[1].rotation += 0.003;
                mirrorCollection.mirrors[2].rotation += 0.001;
                mirrorCollection.mirrors[0].position.x += 1;

                for(var n = 0; n < mirrorCollection.mirrors.length; n++)
                {
                    let mirror = mirrorCollection.mirrors[n];
                    let vertices = mirror.vertices;

                    ctx.reset();
                    ctx.lineWidth = 5;
                    ctx.lineJoin = "round";

                    if(mirror.reflecting)
                    {
                        ctx.strokeStyle = "#ff0000";
                        ctx.shadowColor = "#ff0000";
                        ctx.shadowBlur = 20;
                    }

                    else
                    {
                        ctx.strokeStyle = "#222222";
                    }

                    ctx.save();
                    ctx.translate(mirror.position.x, mirror.position.y);
                    ctx.rotate(mirror.rotation);
                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);

                    for(var m = 1; m < vertices.length; m++)
                    {
                        ctx.lineTo(vertices[m].x, vertices[m].y);
                    }

                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }

                for(var n = 0; n < lasers.length; n++)
                {
                    let laser = lasers[n];
                    let intersections = mirrorCollection.laser(laser);

                    ctx.reset();
                    ctx.lineWidth = 3;
                    ctx.lineJoin = "round";
                    ctx.strokeStyle = "hsl(" + laser.hue + ", 100%, 50%)";
                    ctx.shadowColor = ctx.strokeStyle;
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.moveTo(laser.position.x, laser.position.y);
                    
                    for(var m = 0; m < intersections.length; m++)
                    {
                        let intersection = intersections[m];
                        ctx.lineTo(intersection.x, intersection.y);
                    }

                    ctx.stroke();
                }

                request = requestAnimationFrame(render);
            }

            request = requestAnimationFrame(render);

            resize();
            window.onresize = resize;
            window.onkeydown = keydown;
            window.onkeyup = keyup;
            //window.oncontextmenu = function(event) { event.preventDefault(); };

            function resize()
            {
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                if(windowWidth / windowHeight > canvasWidth / canvasHeight)
                {
                    canvas.style.width = `${(windowHeight / windowWidth) * (canvasWidth / canvasHeight) * 100}%`;
                    canvas.style.height = "100%";
                }
                
                else
                {
                    canvas.style.width = "100%";
                    canvas.style.height = `${(windowWidth / windowHeight) * (canvasHeight / canvasWidth) * 100}%`;
                }
            }

            function keydown(event)
            {
                if(!event)
                {
                    event = window.event;
                }
                
                var eventKey = event.key;
                
                if(keysPressed.includes(eventKey) === false)
                {
                    keysPressed.push(eventKey);
                }
            }
            
            function keyup(event)
            {
                if(!event)
                {
                    event = window.event;
                }
                
                var eventKey = event.key;
                
                keysPressed.splice(keysPressed.indexOf(eventKey), 1);
            }

            function distance(p1, p2 = pointOrigin)
            {
                return Math.hypot(p1.x - p2.x, p1.y - p2.y);
            }
            
            function distanceSquared(p1, p2)
            {
                return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
            }
            
            function distanceManhattan(p1, p2)
            {
                return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
            }

            function interpolateLinear(startingValue, endingValue, t)
            {
                return (startingValue + (endingValue - startingValue) * t);
            }

            function interpolatePointToPoint(p1, p2, t)
            {
                return new Point(interpolateLinear(p1.x, p2.x, t), interpolateLinear(p1.y, p2.y, t));
            }

            function calculateAngleDifference(a1, a2)
            {
                var difference = a2 - a1;
                while(difference < -Math.PI)
                    difference += 2 * Math.PI;
                while(difference > Math.PI)
                    difference -= 2 * Math.PI;
                return difference;
            }

            function intersectSegmentSegment(line1, line2)
            {
                let a = line1.p1.x;
                let b = line1.p1.y;
                let c = line1.p2.x;
                let d = line1.p2.y;
                let p = line2.p1.x;
                let q = line2.p1.y;
                let r = line2.p2.x;
                let s = line2.p2.y;
                var det, gamma, lambda;
                det = (c - a) * (s - q) - (r - p) * (d - b);

                if (det === 0)
                {
                    return false;
                }

                else
                {
                    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
                    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
                    return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
                }
            };

            function intersectionLineLine(line1, line2)
            {
                let x1 = line1.p1.x;
                let y1 = line1.p1.y;
                let x2 = line1.p2.x;
                let y2 = line1.p2.y;
                let x3 = line2.p1.x;
                let y3 = line2.p1.y;
                let x4 = line2.p2.x;
                let y4 = line2.p2.y;

                if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4))
                {
                    return false;
                }

                denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

                if (denominator === 0)
                {
                    return false;
                }

                let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
                let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

                if (ua < 0 || ua > 1 || ub < 0 || ub > 1)
                {
                    return false;
                }

                let x = x1 + ua * (x2 - x1);
                let y = y1 + ua * (y2 - y1);

                return new Point(x, y);
            }
            
        </script>
    </body>
</html>