<!DOCTYPE HTML>
<html>
    <head>
        <title>Laser Simulation</title>
        <script src="./lodash.js"></script>
    </head>
    
    <body onresize="resize();">
        <canvas id="canvas" width="1920" height="1080"></canvas>
        <canvas id="canvas-buffer" class="hidden"></canvas>

        <style>

            body
            {
                background-color: #000000;
                overflow: hidden;
                margin: 0;
                padding: 0;
            }

            #canvas
            {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }

            .hidden
            {
                visibility: hidden;
                pointer-events: none;
            }
            
        </style>
        
        <script>

            class Point
            {
                constructor(x = 0, y = 0)
                {
                    this.x = x;
                    this.y = y;
                }

                addTo(p)
                {
                    this.x += p.x;
                    this.y += p.y;
                }

                addToPolar(r, a)
                {
                    this.x += r * Math.cos(a);
                    this.y += r * Math.sin(a);
                }

                subtractTo(p)
                {
                    this.x -= p.x;
                    this.y -= p.y;
                }

                scale(xs, ys = xs)
                {
                    this.x *= xs;
                    this.y *= ys;
                }

                rotateAroundPoint(p, rotation)
                {
                    let cosine = Math.cos(rotation);
                    let sine = Math.sin(rotation);
                    let xD = this.x - p.x;
                    let yD = this.y - p.y;
                    this.x = cosine * xD - sine * yD + p.x;
                    this.y = sine * xD + cosine * yD + p.y;
                }

                interpolateToPointLinear(p, t)
                {
                    this.x = interpolateLinear(this.x, p.x, t);
                    this.y = interpolateLinear(this.y, p.y, t);
                }

                interpolateToPointQuadratic(p, t)
                {
                    this.x = interpolateLinear(this.x, p.x, t);
                    this.y = interpolateLinear(this.y, p.y, t);
                }
            }

            class Line
            {
                constructor(p1, p2)
                {
                    this.p1 = p1;
                    this.p2 = p2;
                }

                addTo(p)
                {
                    this.p1.addTo(p);
                    this.p2.addTo(p);
                }

                subtractTo(p)
                {
                    this.p1.subtractTo(p);
                    this.p2.subtractTo(p);
                }

                rotateAroundPoint(p, rotation)
                {
                    this.p1.rotateAroundPoint(p, rotation);
                    this.p2.rotateAroundPoint(p, rotation);
                }

                getAngle()
                {
                    let newPoint = _.cloneDeep(this.p1);
                    newPoint.subtractTo(this.p2);
                    return Math.atan2(newPoint.y, newPoint.x);
                }
            }

            class Mirror
            {
                constructor(position, rotation, vertices = [])
                {
                    this.position = position;
                    this.rotation = rotation;
                    this.vertices = vertices;
                    this.reflecting = true;
                }

                getSide(sideNumber)
                {
                    return new Line(this.vertices[sideNumber % this.vertices.length], this.vertices[(sideNumber + 1) % this.vertices.length]);
                }

                getSideAbsolute(sideNumber)
                {
                    let absoluteSide = _.cloneDeep(this.getSide(sideNumber));
                    absoluteSide.rotateAroundPoint(pointOrigin, this.rotation);
                    absoluteSide.addTo(this.position);
                    return absoluteSide;
                }

                getExtremes()
                {
                    let leftMost;
                    let rightMost;
                    let upMost;
                    let downMost;

                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let vertex = this.vertices[n];                    

                        if(leftMost === undefined || vertex.x <= leftMost.x)
                        {
                            leftMost = vertex;
                        }

                        if(rightMost === undefined || vertex.x >= rightMost.x)
                        {
                            rightMost = vertex;
                        }

                        if(upMost === undefined || vertex.y <= upMost.y)
                        {
                            upMost = vertex;
                        }

                        if(downMost === undefined || vertex.y >= downMost.y)
                        {
                            downMost = vertex;
                        }
                    }

                    return {
                        leftMost: leftMost,
                        rightMost: rightMost,
                        upMost: upMost,
                        downMost, downMost
                    };
                }

                findArea()
                {
                    if(this.vertices.length < 3)
                    {
                        return false;
                    }

                    let extremes = this.getExtremes();
                    canvasBuffer.width = Math.round(Math.abs(extremes.leftMost.x - extremes.rightMost.x));
                    canvasBuffer.height = Math.round(Math.abs(extremes.upMost.y - extremes.downMost.y));

                    ctxBuffer.clearRect(0, 0, canvasBuffer.width, canvasBuffer.height);
                    ctxBuffer.beginPath();
                    ctxBuffer.moveTo(this.vertices[0].x - extremes.leftMost.x, this.vertices[0].y - extremes.upMost.y);

                    for(var n = 1; n < this.vertices.length; n++)
                    {
                        ctxBuffer.lineTo(this.vertices[n].x - extremes.leftMost.x, this.vertices[n].y - extremes.upMost.y);
                    }
                    
                    ctxBuffer.closePath();
                    ctxBuffer.fill();

                    let data = ctxBuffer.getImageData(0, 0, canvasBuffer.width, canvasBuffer.height).data;
                    let dataFiltered = [];

                    for(var n = 0; n < data.length; n += 4)
                    {
                        dataFiltered.push(data[n + 3]);
                    }

                    dataFiltered = dataFiltered.filter(function(alpha)
                    {
                        return alpha >= 0.5;
                    });

                    return dataFiltered.length;
                }

                findCenter()
                {
                    let average = new Point(0, 0);

                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let vertex = this.vertices[n];
                        average.addTo(vertex);
                    }

                    average.scale(1 / this.vertices.length);

                    return average;
                }

                subdivide(vertexMultiplier = 2)
                {
                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let side = this.getSide(n);
                        let interpolations = [];

                        for(var m = 1; m < vertexMultiplier; m++)
                        {
                            this.vertices.splice(n + 1, 0, interpolatePointToPoint(side.p1, side.p2, m / (vertexMultiplier + 1)));
                            n++;
                        }
                    }
                }

                smoothen()
                {
                    if(this.vertices.length === 0)
                    {
                        return;
                    }

                    let initialArea = this.findArea();
                    let average = this.findCenter();

                    let distances = [];
                    let distanceToClosestVertex;
                    let distanceToFarthestVertex;

                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let vertex = this.vertices[n];
                        let distanceToVertex = distance(vertex);
                        distances.push(distanceToVertex);

                        if(distanceToClosestVertex === undefined || distanceToVertex < distanceToClosestVertex)
                        {
                            distanceToClosestVertex = distanceToVertex;
                        }

                        if(distanceToFarthestVertex === undefined || distanceToVertex > distanceToFarthestVertex)
                        {
                            distanceToFarthestVertex = distanceToVertex;
                        }
                    }

                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let vertex = this.vertices[n];
                        let distanceToVertex = distances[n];
                        let t = (distanceToVertex - distanceToClosestVertex) / (distanceToFarthestVertex - distanceToClosestVertex);
                        t = 0.2 * t;
                        console.log(t);
                        vertex.interpolateToPointLinear(average, t);
                    }


                    let finalArea = this.findArea();
                }

                makeRectangle(width, height)
                {
                    let halfWidth = width / 2;
                    let halfHeight = height / 2;
                    let topLeftCorner = new Point(-halfWidth, -halfHeight);
                    let topRightCorner = new Point(halfWidth, -halfHeight);
                    let bottomRightCorner = new Point(halfWidth, halfHeight);
                    let bottomLeftCorner = new Point(-halfWidth, halfHeight);
                    this.vertices = [topLeftCorner, topRightCorner, bottomRightCorner, bottomLeftCorner];
                }

                makeCircle(radius, vertexCount)
                {
                    this.vertices = [];

                    for(var n = 0; n < vertexCount; n++)
                    {
                        let vertex = new Point();
                        vertex.addToPolar(radius, n / vertexCount * 2 * Math.PI);
                        this.vertices.push(vertex);
                    }
                }

                makeRegularPolygon(radius, vertexCount)
                {
                    this.vertices = [];

                    for(var n = 0; n < vertexCount; n++)
                    {
                        this.vertices.push(new Point(radius * Math.cos(n / vertexCount * 2 * Math.PI), radius * Math.sin(n / vertexCount * 2 * Math.PI)));
                    }
                }

                makeBlob(vertexCount)
                {
                    this.vertices = [];

                    for(var n = 0; n < vertexCount; n++)
                    {

                    }
                }

                laser(segment, sideIgnore)
                {
                    let closestIntersection;
                    let distanceToClosestIntersection;
                    let closestSide;

                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let side = this.getSideAbsolute(n);

                        if(_.isEqual(side, sideIgnore))
                        {
                            continue;
                        }

                        if(intersectSegmentSegment(segment, side))
                        {
                            let intersection = intersectionLineLine(segment, side);
                            let distanceToIntersection = distance(segment.p1, intersection);

                            if(closestIntersection === undefined ||  distanceToIntersection < distanceToClosestIntersection)
                            {
                                closestIntersection = intersection;
                                distanceToClosestIntersection = distanceToIntersection;
                                closestSide = side;
                            }
                        }
                    }

                    if(closestIntersection !== undefined)
                    {
                        return {intersection: _.cloneDeep(closestIntersection), distanceToIntersection: distanceToClosestIntersection, side: _.cloneDeep(closestSide)};
                    }

                    return false;
                }
            }

            class MirrorCollection
            {
                constructor(mirrors)
                {
                    this.mirrors = mirrors;
                }

                laser(laserBeam, intersections = [], sideIgnore = null)
                {
                    if(intersections.length === LASER_MAX_BOUNCES + 1)
                    {
                        return intersections;
                    }

                    let laserLine = new Line(laserBeam.position, new Point(laserBeam.position.x + LASER_RANGE * Math.cos(laserBeam.rotation), laserBeam.position.y + LASER_RANGE * Math.sin(laserBeam.rotation)));
                    let closestMirror;
                    let closestIntersection;
                    let distanceToClosestIntersection;
                    let closestSide;

                    for(var n = 0; n < this.mirrors.length; n++)
                    {
                        let mirror = this.mirrors[n];

                        for(var m = 0; m < mirror.vertices.length; m++)
                        {
                            let side = mirror.getSideAbsolute(m);

                            if(_.isEqual(side, sideIgnore))
                            {
                                continue;
                            }

                            if(intersectSegmentSegment(laserLine, side))
                            {
                                let intersection = intersectionLineLine(laserLine, side);
                                let distanceToIntersection = distance(laserBeam.position, intersection);

                                if(closestIntersection === undefined ||  distanceToIntersection < distanceToClosestIntersection)
                                {
                                    closestMirror = mirror;
                                    closestIntersection = intersection;
                                    distanceToClosestIntersection = distanceToIntersection;
                                    closestSide = side;
                                }
                            }
                        }
                    }

                    if(closestMirror === undefined)
                    {
                        let point = _.cloneDeep(laserBeam.position);
                        point.addToPolar(LASER_RANGE, laserBeam.rotation);
                        intersections.push(point);
                        return intersections;
                    }

                    let newIntersections = _.cloneDeep(intersections);
                    newIntersections.push(closestIntersection);

                    // angle of incidence code start
                    let angleOfIncidence = Math.PI / 2 + laserBeam.rotation - closestSide.getAngle();

                    while(angleOfIncidence > Math.PI)
                    {
                        angleOfIncidence -= Math.PI;
                    }

                    while(angleOfIncidence < 0)
                    {
                        angleOfIncidence += Math.PI;
                    }

                    if(angleOfIncidence > Math.PI / 2)
                    {
                        angleOfIncidence = Math.PI - angleOfIncidence;
                    }

                    angleOfIncidence = angleOfIncidence;

                    if(closestMirror.reflecting)
                    {
                        return this.laser(new Laser(closestIntersection, 2 * closestSide.getAngle() - laserBeam.rotation), newIntersections, closestSide);
                    }

                    else
                    {
                        intersections.push(closestIntersection);
                        return intersections;
                    }
                }
            }

/*            class Mirror
            {
                constructor(position, rotation, vertices = [])
                {
                    this.reflecting = true;
                    this.position = position;
                    this.rotation = rotation;
                    this.vertices = vertices;
                }

                getSide(sideNumber)
                {
                    return new Line(this.vertices[sideNumber % this.vertices.length], this.vertices[(sideNumber + 1) % this.vertices.length]);
                }

                getSideAbsolute(sideNumber)
                {
                    let absoluteSide = _.cloneDeep(this.getSide(sideNumber));
                    absoluteSide.rotateAroundPoint(pointOrigin, this.rotation);
                    absoluteSide.addTo(this.position);
                    return absoluteSide;
                }

                subdivide(vertexMultiplier = 2)
                {
                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let side = this.getSide(n);
                        let interpolations = [];

                        for(var m = 1; m < vertexMultiplier; m++)
                        {
                            this.vertices.splice(n + 1, 0, interpolatePointToPoint(side.p1, side.p2, m / (vertexMultiplier + 1)));
                            n++;
                        }
                    }
                }

                makeRectangle(width, height)
                {
                    let halfWidth = width / 2;
                    let halfHeight = height / 2;
                    let topLeftCorner = new Point(-halfWidth, -halfHeight);
                    let topRightCorner = new Point(halfWidth, -halfHeight);
                    let bottomRightCorner = new Point(halfWidth, halfHeight);
                    let bottomLeftCorner = new Point(-halfWidth, halfHeight);
                    this.vertices = [topLeftCorner, topRightCorner, bottomRightCorner, bottomLeftCorner];
                }

                makeCircle(radius, vertexCount)
                {
                    this.vertices = [];

                    for(var n = 0; n < vertexCount; n++)
                    {
                        let vertex = new Point();
                        vertex.addToPolar(radius, n / vertexCount * 2 * Math.PI);
                        this.vertices.push(vertex);
                    }
                }
            }*/

            class Laser
            {
                constructor(position, rotation, hue = 0)
                {
                    this.position = position;
                    this.rotation = rotation;
                    this.hue = hue;
                }

                pointTo(p)
                {
                    this.rotation = Math.atan2(p.y - this.position.y, p.x - this.position.x);
                }
            }

            CanvasRenderingContext2D.prototype.reset = function()
            {
                this.direction = "ltr";
                this.fillStyle = "#000000";
                this.filter = "none";
                this.font = "10px sans-serif";
                this.globalAlpha = 1;
                this.globalCompositeOperation = "source-over";
                this.imageSmoothingEnabled = true;
                this.imageSmoothingQuality = "low";
                this.lineCap = "butt";
                this.lineDashOffset = 0;
                this.lineJoin = "miter";
                this.lineWidth = 1;
                this.miterLimit = 10;
                this.shadowBlur = 0;
                this.shadowColor = "rgba(0, 0, 0, 0)";
                this.shadowOffsetX = 0;
                this.shadowOffsetY = 0;
                this.strokeStyle = "#000000";
                this.textAlign = "start";
                this.textBaseline = "alphabetic";
            }

            var request;
            const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
            const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
            const canvas = document.getElementById("canvas");
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const ctx = canvas.getContext("2d", {alpha: false});
            const canvasBuffer = document.getElementById("canvas-buffer");
            const ctxBuffer = canvasBuffer.getContext("2d", {alpha: false});
            const pointOrigin = new Point(0, 0);
            const keysPressed = [];
            const LASER_MAX_BOUNCES = 10;
            const LASER_RANGE = 10000;
            var mirror = new Mirror(new Point(500, 500), 0, [new Point(-200, -200), new Point(200, -200), new Point(200, 200), new Point(-200, 200)]);
            //mirror.makeBlob(50);
            var mirror2 = new Mirror(new Point(1000, 600), 0);
            mirror2.makeRegularPolygon(100, 8);
            var mirror3 = new Mirror(new Point(1000, 1000), 0);
            mirror3.makeRegularPolygon(100, 6);
            var mirrorCollection = new MirrorCollection([mirror, mirror2, mirror3]);
            var lasers = [new Laser(new Point(400, 650), 15 * Math.PI / 180, 120)];

            function render()
            {

                if(keysPressed.includes("ArrowLeft"))
                {
                    lasers[0].position.x -= 2;
                }

                if(keysPressed.includes("ArrowRight"))
                {
                    lasers[0].position.x += 2;
                }

                if(keysPressed.includes("ArrowUp"))
                {
                    lasers[0].position.y -= 2;
                }

                if(keysPressed.includes("ArrowDown"))
                {
                    lasers[0].position.y += 2;
                }

                if(keysPressed.includes("a"))
                {
                    lasers[0].rotation -= 0.02;
                }

                if(keysPressed.includes("d"))
                {
                    lasers[0].rotation += 0.02;
                }
                
                ctx.reset();
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                for(var n = 0; n < mirrorCollection.mirrors.length; n++)
                {
                    let mirror = mirrorCollection.mirrors[n];
                    let vertices = mirror.vertices;

                    ctx.reset();
                    ctx.lineWidth = 5;
                    ctx.lineJoin = "round";

                    if(mirror.reflecting)
                    {
                        ctx.strokeStyle = "#ff0000";
                        ctx.shadowColor = "#ff0000";
                        ctx.shadowBlur = 20;
                    }

                    else
                    {
                        ctx.strokeStyle = "#222222";
                    }

                    ctx.save();
                    ctx.translate(mirror.position.x, mirror.position.y);
                    ctx.rotate(mirror.rotation);
                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);

                    for(var m = 1; m < vertices.length; m++)
                    {
                        ctx.lineTo(vertices[m].x, vertices[m].y);
                    }

                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }

                for(var n = 0; n < lasers.length; n++)
                {
                    let laser = lasers[n];
                    let intersections = mirrorCollection.laser(laser);

                    ctx.reset();
                    ctx.lineWidth = 3;
                    ctx.lineJoin = "round";
                    ctx.strokeStyle = "hsl(" + laser.hue + ", 100%, 50%)";
                    ctx.shadowColor = ctx.strokeStyle;
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.moveTo(laser.position.x, laser.position.y);
                    
                    for(var m = 0; m < intersections.length; m++)
                    {
                        let intersection = intersections[m];
                        ctx.lineTo(intersection.x, intersection.y);
                    }

                    ctx.stroke();
                }

                request = requestAnimationFrame(render);
            }

            resize();
            window.onresize = resize;
            window.onkeydown = keydown;
            window.onkeyup = keyup;
            window.onload = function()
            {
                request = requestAnimationFrame(render);
            }

            function resize()
            {
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                if(windowWidth / windowHeight > canvasWidth / canvasHeight)
                {
                    canvas.style.width = `${(windowHeight / windowWidth) * (canvasWidth / canvasHeight) * 100}%`;
                    canvas.style.height = "100%";
                }
                
                else
                {
                    canvas.style.width = "100%";
                    canvas.style.height = `${(windowWidth / windowHeight) * (canvasHeight / canvasWidth) * 100}%`;
                }
            }

            function keydown(event)
            {
                if(!event)
                {
                    event = window.event;
                }
                
                var eventKey = event.key;
                
                if(keysPressed.includes(eventKey) === false)
                {
                    keysPressed.push(eventKey);
                }
            }
            
            function keyup(event)
            {
                if(!event)
                {
                    event = window.event;
                }
                
                var eventKey = event.key;
                
                keysPressed.splice(keysPressed.indexOf(eventKey), 1);
            }

            function distance(p1, p2 = pointOrigin)
            {
                return Math.hypot(p1.x - p2.x, p1.y - p2.y);
            }
            
            function distanceSquared(p1, p2)
            {
                return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
            }
            
            function distanceManhattan(p1, p2)
            {
                return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
            }

            function interpolateLinear(startingValue, endingValue, t)
            {
                return (startingValue + (endingValue - startingValue) * t);
            }

            function interpolateQuadratic(startingValue, endingValue, t)
            {
                return interpolateLinear(startingValue, endingValue, t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);
            }

            function interpolatePointToPoint(p1, p2, t)
            {
                return new Point(interpolateLinear(p1.x, p2.x, t), interpolateLinear(p1.y, p2.y, t));
            }

            function calculateAngleDifference(a1, a2)
            {
                var difference = a2 - a1;
                while(difference < -Math.PI)
                    difference += 2 * Math.PI;
                while(difference > Math.PI)
                    difference -= 2 * Math.PI;
                return difference;
            }

            function intersectSegmentSegment(line1, line2)
            {
                let a = line1.p1.x;
                let b = line1.p1.y;
                let c = line1.p2.x;
                let d = line1.p2.y;
                let p = line2.p1.x;
                let q = line2.p1.y;
                let r = line2.p2.x;
                let s = line2.p2.y;
                var det, gamma, lambda;
                det = (c - a) * (s - q) - (r - p) * (d - b);

                if (det === 0)
                {
                    return false;
                }

                else
                {
                    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
                    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
                    return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
                }
            };

            function intersectionLineLine(line1, line2)
            {
                let x1 = line1.p1.x;
                let y1 = line1.p1.y;
                let x2 = line1.p2.x;
                let y2 = line1.p2.y;
                let x3 = line2.p1.x;
                let y3 = line2.p1.y;
                let x4 = line2.p2.x;
                let y4 = line2.p2.y;

                if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4))
                {
                    return false;
                }

                denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

                if (denominator === 0)
                {
                    return false;
                }

                let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
                let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

                if (ua < 0 || ua > 1 || ub < 0 || ub > 1)
                {
                    return false;
                }

                let x = x1 + ua * (x2 - x1);
                let y = y1 + ua * (y2 - y1);

                return new Point(x, y);
            }

            function intersectionSegmentCircle(line, circle)
            {
                var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;
                v1 = {};
                v2 = {};
                v1.x = line.p2.x - line.p1.x;
                v1.y = line.p2.y - line.p1.y;
                v2.x = line.p1.x - circle.position.x;
                v2.y = line.p1.y - circle.position.y;
                b = (v1.x * v2.x + v1.y * v2.y);
                c = 2 * (v1.x * v1.x + v1.y * v1.y);
                b *= -2;
                d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));
                if(isNaN(d))
                {
                    return [];
                }
                u1 = (b - d) / c;
                u2 = (b + d) / c;    
                retP1 = {};
                retP2 = {}  
                ret = [];
                if(u1 <= 1 && u1 >= 0)
                {
                    /*retP1.x = line.p1.x + v1.x * u1;
                    retP1.y = line.p1.y + v1.y * u1;*/
                    retP1 = new Point(line.p1.x + v1.x * u1, line.p1.y + v1.y * u1);
                    ret[0] = retP1;
                }
                if(u2 <= 1 && u2 >= 0)
                {
                    /*retP2.x = line.p1.x + v1.x * u2;
                    retP2.y = line.p1.y + v1.y * u2;*/
                    retP2 = new Point(line.p1.x + v1.x * u2, line.p1.y + v1.y * u2);
                    ret[ret.length] = retP2;
                }       
                return ret;
            }
            
        </script>
    </body>
</html>