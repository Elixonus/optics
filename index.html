<!DOCTYPE HTML>
<html>
    <head>
        <title>Laser Simulation</title>
        <script src="./lodash.js"></script>
    </head>
    
    <body onresize="resize();">
        <canvas id="canvas" width="1920" height="1080"></canvas>

        <style>

            body
            {
                background-color: #000000;
                overflow: hidden;
                margin: 0;
                padding: 0;
            }

            #canvas
            {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            
        </style>
        
        <script>

            class Point
            {
                constructor(x, y)
                {
                    this.x = x;
                    this.y = y;
                }

                addTo(p)
                {
                    this.x += p.x;
                    this.y += p.y;
                }
            }

            class Line
            {
                constructor(p1, p2)
                {
                    this.p1 = p1;
                    this.p2 = p2;
                }
            }

            class Circle
            {
                constructor(center, radius)
                {
                    this.center = center;
                    this.radius = radius;
                }
            }
            
            class Rectangle
            {
                constructor(center, width, height)
                {
                    this.center = center;
                    this.width = width;
                    this.height = height;
                }
            }

            class MirrorCollection
            {
                constructor(mirrors)
                {
                    this.mirrors = mirrors;
                }

                laser(center, angle, intersections = [])
                {
                    if(intersections.length === 10)
                    {
                        return intersections;
                    }

                    let closestIntersection;
                    let distanceToClosestIntersection;

                    for(var n = 0; n < this.mirrors.length; n++)
                    {
                        let mirror = this.mirrors[n];
                        let laserLine = new Line(center, new Point(center.x + 10000 * Math.cos(angle), center.y + 10000 * Math.sin(angle)));

                        for(var m = 0; m < mirror.vertices.length; m++)
                        {
                            let vertex = _.cloneDeep(mirror.vertices[m]);
                            rotatePointAroundPoint(vertex, pointOrigin, mirror.rotation);
                            vertex.addTo(mirror.center);
                            let nextVertex = _.cloneDeep(mirror.vertices[(m + 1) % mirror.vertices.length]);
                            rotatePointAroundPoint(nextVertex, pointOrigin, mirror.rotation);
                            nextVertex.addTo(mirror.center);
                            let mirrorSide = new Line(vertex, nextVertex);

                            if(intersectSegmentSegment(laserLine, mirrorSide))
                            {
                                let intersection = intersectionLineLine(laserLine, mirrorSide);
                                let distanceToIntersection = distance(center, intersection);

                                if((closestIntersection === undefined || distanceToIntersection < distanceToClosestIntersection) && distanceToIntersection > 10)
                                {
                                    closestIntersection = intersection;
                                    distanceToClosestIntersection = distanceToIntersection;
                                }
                            }
                        }
                    }

                    if(closestIntersection === undefined)
                    {
                        return intersections;
                    }

                    let newIntersections = [];

                    for(var n = 0; n < intersections.length; n++)
                    {
                        newIntersections.push(intersections[n]);
                    }

                    newIntersections.push(closestIntersection);

                    return this.laser(closestIntersection, 2 * Math.PI * Math.random(), newIntersections);
                }
            }

            class Mirror
            {
                constructor(center, rotation, vertices = [])
                {
                    this.active = true;
                    this.reflecting = true;
                    this.center = center;
                    this.rotation = rotation;
                    this.vertices = vertices;
                }

                makeRectangle(width, height)
                {
                    let halfWidth = width / 2;
                    let halfHeight = height / 2;
                    let topLeftCorner = new Point(-halfWidth, -halfHeight);
                    let topRightCorner = new Point(halfWidth, -halfHeight);
                    let bottomRightCorner = new Point(halfWidth, halfHeight);
                    let bottomLeftCorner = new Point(-halfWidth, halfHeight);
                    this.vertices = [topLeftCorner, topRightCorner, bottomRightCorner, bottomLeftCorner];
                }
            }

            CanvasRenderingContext2D.prototype.reset = function()
            {
                this.direction = "ltr";
                this.fillStyle = "#000000";
                this.filter = "none";
                this.font = "10px sans-serif";
                this.globalAlpha = 1;
                this.globalCompositeOperation = "source-over";
                this.imageSmoothingEnabled = true;
                this.imageSmoothingQuality = "low";
                this.lineCap = "butt";
                this.lineDashOffset = 0;
                this.lineJoin = "miter";
                this.lineWidth = 1;
                this.miterLimit = 10;
                this.shadowBlur = 0;
                this.shadowColor = "rgba(0, 0, 0, 0)";
                this.shadowOffsetX = 0;
                this.shadowOffsetY = 0;
                this.strokeStyle = "#000000";
                this.textAlign = "start";
                this.textBaseline = "alphabetic";
            }

            var request;
            const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
            const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
            const canvas = document.getElementById("canvas");
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const ctx = canvas.getContext("2d");
            const pointOrigin = new Point(0, 0);
            var mirror = new Mirror(new Point(400, 800), 0);
            mirror.makeRectangle(100, 200);
            var mirrorCollection = new MirrorCollection([mirror]);
            var laserCenter = new Point(400, 150);
            var laserAngle = Math.PI / 2;

            function render()
            {
                let intersections = mirrorCollection.laser(laserCenter, laserAngle);
                ctx.reset();
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.reset();
                ctx.lineWidth = 3;
                ctx.strokeStyle = "#00ff00";
                ctx.shadowColor = "#00ff00";
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.moveTo(laserCenter.x, laserCenter.y);
                for(var n = 0; n < intersections.length; n++)
                {
                    let intersection = intersections[n];
                    ctx.lineTo(intersection.x, intersection.y);
                }
                ctx.stroke();

                mirrorCollection.mirrors[0].rotation += 0.01;

                ctx.reset();
                ctx.lineWidth = 5;
                ctx.strokeStyle = "#ff0000";
                ctx.shadowColor = "#ff0000";
                ctx.shadowBlur = 20;

                for(var n = 0; n < mirrorCollection.mirrors.length; n++)
                {
                    let mirror = mirrorCollection.mirrors[n];
                    let vertices = mirror.vertices;

                    ctx.save();
                    ctx.translate(mirror.center.x, mirror.center.y);
                    ctx.rotate(mirror.rotation);
                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);

                    for(var m = 1; m < vertices.length; m++)
                    {
                        ctx.lineTo(vertices[m].x, vertices[m].y);
                    }

                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }

                request = requestAnimationFrame(render);
            }

            request = requestAnimationFrame(render);

            function resize()
            {
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                if(windowWidth / windowHeight > canvasWidth / canvasHeight)
                {
                    canvas.style.width = `${(windowHeight / windowWidth) * (canvasWidth / canvasHeight) * 100}%`;
                    canvas.style.height = "100%";
                }
                
                else
                {
                    canvas.style.width = "100%";
                    canvas.style.height = `${(windowWidth / windowHeight) * (canvasHeight / canvasWidth) * 100}%`;
                }
            }

            resize();

            function distance(p1, p2 = pointOrigin)
            {
                return Math.hypot(p1.x - p2.x, p1.y - p2.y);
            }
            
            function distanceSquared(p1, p2)
            {
                return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
            }
            
            function distanceManhattan(p1, p2)
            {
                return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
            }

            function rotatePointAroundPoint(p1, p2, rotation)
            {
                let cosine = Math.cos(rotation);
                let sine = Math.sin(rotation);
                let xT = p1.x - p2.x;
                let yT = p1.y - p2.y;
                let result = new Point(cosine * xT - sine * yT + p2.x, sine * xT + cosine * yT + p2.y);
                p1.x = result.x;
                p1.y = result.y;
            }

            function intersectSegmentSegment(line1, line2)
            {
                let a = line1.p1.x;
                let b = line1.p1.y;
                let c = line1.p2.x;
                let d = line1.p2.y;
                let p = line2.p1.x;
                let q = line2.p1.y;
                let r = line2.p2.x;
                let s = line2.p2.y;
                var det, gamma, lambda;
                det = (c - a) * (s - q) - (r - p) * (d - b);

                if (det === 0)
                {
                    return false;
                }

                else
                {
                    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
                    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
                    return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
                }
            };

            function intersectionLineLine(line1, line2)
            {
                let x1 = line1.p1.x;
                let y1 = line1.p1.y;
                let x2 = line1.p2.x;
                let y2 = line1.p2.y;
                let x3 = line2.p1.x;
                let y3 = line2.p1.y;
                let x4 = line2.p2.x;
                let y4 = line2.p2.y;

                if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4))
                {
                    return false;
                }

                denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

                if (denominator === 0)
                {
                    return false;
                }

                let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
                let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

                if (ua < 0 || ua > 1 || ub < 0 || ub > 1)
                {
                    return false;
                }

                let x = x1 + ua * (x2 - x1);
                let y = y1 + ua * (y2 - y1);

                return new Point(x, y);
            }
            
        </script>
    </body>
</html>