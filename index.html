<!DOCTYPE HTML>
<html>
    <head>
        <title>Laser Simulation</title>
        <script src="./lodash.js"></script>
    </head>
    
    <body onresize="resize();">
        <canvas id="canvas" width="1920" height="1080"></canvas>

        <style>

            *
            {
                cursor: none;
                margin: 0;
                padding: 0;
            }

            body
            {
                background-color: #000000;
            }

            #canvas
            {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: -1;
            }

            .hidden
            {
                visibility: hidden;
                pointer-events: none;
            }
            
        </style>
        
        <script>

            class Point
            {
                constructor(x = 0, y = 0)
                {
                    this.x = x;
                    this.y = y;
                    return this;
                }

                clone()
                {
                    return new Point(this.x, this.y);
                }

                setTo(p)
                {
                    this.x = p.x;
                    this.y = p.y;
                    return this;
                }

                addTo(p)
                {
                    this.x += p.x;
                    this.y += p.y;
                    return this;
                }

                addToPolar(r, a)
                {
                    this.x += r * Math.cos(a);
                    this.y += r * Math.sin(a);
                    return this;
                }

                subtractTo(p)
                {
                    this.x -= p.x;
                    this.y -= p.y;
                    return this;
                }

                multiplyBy(x)
                {
                    return this.scale(x);
                }

                divideBy(x)
                {
                    return this.scale(1 / x);
                }

                scale(xs, ys = xs)
                {
                    this.x *= xs;
                    this.y *= ys;
                    return this;
                }

                rotateAroundPoint(p, rotation)
                {
                    let cosine = Math.cos(rotation);
                    let sine = Math.sin(rotation);
                    let xD = this.x - p.x;
                    let yD = this.y - p.y;
                    this.x = cosine * xD - sine * yD + p.x;
                    this.y = sine * xD + cosine * yD + p.y;
                    return this;
                }

                absolute(x = true, y = true)
                {
                    if(x)
                    {
                        this.x = Math.abs(x);
                    }

                    if(y)
                    {
                        this.y = Math.abs(y);
                    }

                    return this;
                }

                interpolateToPointLinear(p, t)
                {
                    this.x = interpolateLinear(this.x, p.x, t);
                    this.y = interpolateLinear(this.y, p.y, t);
                    return this;
                }

                interpolateToPointQuadratic(p, t)
                {
                    this.x = interpolateLinear(this.x, p.x, t);
                    this.y = interpolateLinear(this.y, p.y, t);
                    return this;
                }

                midPointTo(p)
                {
                    this.x = (this.x + p.x) / 2;
                    this.y = (this.y + p.y) / 2;
                    return this;
                }

                getMagnitude()
                {
                    return distance(this);
                }
            }

            class Line
            {
                constructor(p1, p2)
                {
                    this.p1 = p1;
                    this.p2 = p2;
                    return this;
                }

                static fromRay(center, angle)
                {
                    return new Line(center, center.clone().addToPolar(1, angle));
                }

                static fromPointSlope(point, slope)
                {
                    return new Line(point, point.addTo(new Point(1, slope)));
                }

                clone()
                {
                    return new Line(this.p1.clone(), this.p2.clone());
                }

                addTo(p)
                {
                    this.p1.addTo(p);
                    this.p2.addTo(p);
                    return this;
                }

                subtractTo(p)
                {
                    this.p1.subtractTo(p);
                    this.p2.subtractTo(p);
                    return this;
                }

                rotateAroundPoint(p, rotation)
                {
                    this.p1.rotateAroundPoint(p, rotation);
                    this.p2.rotateAroundPoint(p, rotation);
                    return this;
                }

                getPerpendicularThroughPoint(p)
                {
                    // not done
                    return new Line(p, p.clone().addTo());
                }

                getLength()
                {
                    return distance(this.p1, this.p2);
                }

                getAngle()
                {
                    let differencePoint = this.p1.clone().subtractTo(this.p2);
                    return Math.atan2(differencePoint.y, differencePoint.x);
                }

                getScalarProductBetweenLine(l)
                {
                    let vector1 = this.p1.clone().subtractTo(this.p2);
                    let vector2 = l.p1.clone().subtractTo(l.p2);
                    let scalarProduct = vector1.x * vector2.x + vector1.y * vector2.y;
                    return scalarProduct;
                }

                getCrossProductBetweenLine(l)
                {
                    let vector1 = this.p1.clone().subtractTo(this.p2);
                    let vector2 = l.p1.clone().subtractTo(l.p2);
                    return vector1.x * vector2.y - vector1.y * vector2.x;
                }

                getAngleBetweenLine(l)
                {
                    return Math.acos(this.getScalarProductBetweenLine(l) / (this.getLength() * l.getLength()));
                }

                getAngleBetweenLinePerpendicular(l)
                {
                    return Math.asin(this.getSineOfAngleBetweenLinePerpendicular(l));
                }

                getSineOfAngleBetweenLinePerpendicular(l)
                {
                    return Math.abs(this.getScalarProductBetweenLine(l)) / (this.getLength() * l.getLength());
                }

                getAngleReflected(angleOfIncidence)
                {
                    return 2 * this.getAngle() - angleOfIncidence;
                }
            }

            class Object
            {
                constructor(position, rotation)
                {
                    this.setPositionTo(position);
                    this.setRotationTo(rotation);
                }

                setPositionTo(position)
                {
                    if(position.constructor.name === "Point")
                    {
                        this.position = position;
                    }

                    else if(position.constructor.name === "Animation")
                    {
                        this.positionAnimation = position;
                        this.tick();
                    }

                    return this;
                }

                setRotationTo(rotation)
                {
                    if(isNaN(rotation))
                    {
                        this.rotationAnimation = rotation;
                        this.tick();
                    }

                    else
                    {
                        this.rotation = rotation;
                    }

                    return this;
                }

                tick()
                {
                    if(this.hasOwnProperty("positionAnimation"))
                    {
                        let result = this.positionAnimation.getValues();
                        this.position = new Point(result[0], result[1]);
                        this.positionAnimation.tick();
                    }

                    if(this.hasOwnProperty("rotationAnimation"))
                    {
                        this.rotation = this.rotationAnimation.getValues();
                        this.rotationAnimation.tick();
                    }
                }
            }

            class Scene
            {
                constructor(objects = [])
                {
                    this.lasers = [];
                    this.mirrors = [];

                    if(Array.isArray(objects))
                    {
                        return this.addObjects(objects);
                    }

                    return this.addObject(objects);
                }

                get draggedMirror()
                {
                    for(var n = 0; n < this.mirrors.length; n++)
                    {
                        let mirror = this.mirrors[n];

                        if(mirror.isDragged)
                        {
                            return mirror;
                        }
                    }

                    return false;
                }

                addLaser(laser)
                {
                    this.lasers.push(laser);
                    return this;
                }

                removeLaser(laser)
                {
                    this.lasers.splice(this.lasers.indexOf(laser), 1);
                    return this;
                }

                addLasers(lasers)
                {
                    this.lasers = this.lasers.concat(lasers);
                    return this;
                }

                addMirror(mirror)
                {
                    this.mirrors.push(mirror);
                    return this;
                }

                removeMirror(mirror)
                {
                    this.mirrors.splice(this.mirrors.indexOf(mirror), 1);
                    return this;
                }

                addMirrors(mirrors)
                {
                    this.mirrors = this.mirrors.concat(mirrors);
                    return this;
                }

                addObject(object)
                {
                    if(object.constructor.name === "Laser")
                    {
                        this.addLaser(object);
                    }

                    else if(object.constructor.name === "Mirror")
                    {
                        this.addMirror(object);
                    }
                    
                    return this;
                }

                removeObject(object)
                {
                    if(object.constructor.name === "Laser")
                    {
                        this.removeLaser(object);
                    }

                    if(object.constructor.name === "Mirror")
                    {
                        this.removeMirror(object);
                    }
                }

                addObjects(objects)
                {
                    for(var n = 0; n < objects.length; n++)
                    {
                        this.addObject(objects[n]);
                    }
                    
                    return this;
                }

                getMirrorsWithPointInside(p = pointOrigin)
                {
                    let mirrors = [];

                    for(var n = 0; n < this.mirrors.length; n++)
                    {
                        let mirror = this.mirrors[n];

                        if(mirror.pointInside(p, true))
                        {
                            mirrors.push(mirror);
                        }
                    }

                    return mirrors;
                }

                getClosestObjectToPoint(p = pointOrigin, objects = [])
                {
                    let closestObject;
                    let distanceToClosestObject;

                    for(var n = 0; n < objects.length; n++)
                    {
                        let object = objects[n];
                        let distanceToObject = distance(p, object.position);

                        if(closestObject === undefined || distanceToObject < distanceToClosestObject)
                        {
                            closestObject = object;
                            distanceToClosestObject = distanceToObject;
                        }
                    }

                    if(closestObject === undefined)
                    {
                        return false;
                    }

                    return {
                        object: closestObject,
                        distanceToObject: distanceToClosestObject
                    };
                }

                getClosestMirrorToPoint(p = pointOrigin)
                {
                    let closest = this.getClosestObjectToPoint(p, this.mirrors);
                    return closest;
                }

                getReflectingMirrors()
                {
                    let mirrors = [];

                    for(var n = 0; n < this.mirrors.length; n++)
                    {
                        let mirror = this.mirrors[n];

                        if(mirror.isReflecting)
                        {
                            mirrors.push(mirror);
                        }
                    }

                    return mirrors;
                }

                laser(laser, insideMirrors = [], intersections = [], sideIgnore = null)
                {
                    if(intersections.length === LASER_MAX_COLLISIONS)
                    {
                        return intersections;
                    }
                    
                    let laserLine = Line.fromRay(laser.position, laser.rotation);
                    let closestMirror;
                    let closestIntersection;
                    let distanceToClosestIntersection;
                    let closestSide;

                    for(var n = 0; n < this.mirrors.length; n++)
                    {
                        let mirror = this.mirrors[n];

                        for(var m = 0; m < mirror.vertices.length; m++)
                        {
                            let side = mirror.getSide(m, true);

                            if(_.isEqual(side, sideIgnore))
                            {
                                continue;
                            }

                            let intersection = intersectionSegmentRay(side, laserLine);

                            if(intersection !== false)
                            {
                                let distanceToIntersection = distance(laser.position, intersection);

                                if(closestIntersection === undefined ||  distanceToIntersection < distanceToClosestIntersection)
                                {
                                    closestMirror = mirror;
                                    closestIntersection = intersection;
                                    distanceToClosestIntersection = distanceToIntersection;
                                    closestSide = side;
                                }
                            }
                        }
                    }

                    let newIntersections = _.clone(intersections);

                    if(closestMirror === undefined)
                    {
                        newIntersections.push(laser.position.clone().addToPolar(LASER_RANGE, laser.rotation));
                        return newIntersections;
                    }

                    newIntersections.push(closestIntersection);

                    if(closestMirror.isReflecting)
                    {
                        return this.laser(new Laser(closestIntersection, closestSide.getAngleReflected(laser.rotation)), insideMirrors, newIntersections, closestSide);
                    }

                    else if(closestMirror.isRefracting)
                    {
                        let newInsideMirrors = _.clone(insideMirrors);

                        if(!newInsideMirrors.includes(closestMirror))
                        {
                            newInsideMirrors.push(closestMirror);
                        }

                        else
                        {
                            newInsideMirrors.splice(newInsideMirrors.indexOf(closestMirror), 1);
                        }

                        let incidentIndex = 1;
                        let refractedIndex = 1;

                        if(insideMirrors.length > 0)
                        {
                            incidentIndex = average(getPropertiesOfObjects(insideMirrors, "indexOfRefraction"));
                        }

                        if(newInsideMirrors.length > 0)
                        {
                            refractedIndex = average(getPropertiesOfObjects(newInsideMirrors, "indexOfRefraction"));
                        }

                        let criticalAngle;
                        let criticalAngleSine;

                        if(incidentIndex > refractedIndex)
                        {
                            criticalAngleSine = refractedIndex / incidentIndex;
                            criticalAngle = Math.asin(criticalAngleSine);
                        }

                        else
                        {
                            criticalAngle = Math.PI / 2;
                            criticalAngleSine = 1;
                        }

                        let incidentAngleSine = laserLine.getSineOfAngleBetweenLinePerpendicular(closestSide);
                        let incidentAngle = Math.asin(incidentAngleSine);

                        if(incidentAngleSine >= criticalAngleSine)
                        {
                            newIntersections.push(closestIntersection);
                            return newIntersections;
                        }

                        else
                        {
                            let refractedAngleSine = incidentAngleSine * incidentIndex / refractedIndex;
                            let refractedAngle = Math.asin(refractedAngleSine);
                            return this.laser(new Laser(closestIntersection, laser.rotation - Math.sign(laserLine.getScalarProductBetweenLine(closestSide)) * Math.sign(laserLine.getCrossProductBetweenLine(closestSide)) * (incidentAngle - refractedAngle)), newInsideMirrors, newIntersections, closestSide);
                        }
                    }

                    else if(closestMirror.isAbsorbing)
                    {
                        return newIntersections;
                    }
                }

                getLaserCollisions()
                {
                    let lasersData = [];

                    for(var n = 0; n < this.lasers.length; n++)
                    {
                        let laser = this.lasers[n];
                        lasersData.push(this.laser(laser, this.getMirrorsWithPointInside(laser.position)));
                    }

                    return lasersData;
                }

                tick()
                {
                    for(var n = 0; n < this.lasers.length; n++)
                    {
                        this.lasers[n].tick();
                    }

                    for(var n = 0; n < this.mirrors.length; n++)
                    {
                        this.mirrors[n].tick();
                    }
                }

                load(json)
                {
                    let parsed = JSON.parse(json);
                    this.lasers = parsed.lasers;
                    this.mirrors = parsed.mirrors;
                    
                    return this;
                }
            }

            class Laser extends Object
            {
                constructor(position, rotation)
                {
                    super(position, rotation);
                    return this;
                }

                pointTo(p)
                {
                    this.rotation = Math.atan2(p.y - this.position.y, p.x - this.position.x);
                }
            }

            class Mirror extends Object
            {
                constructor(type, indexOfRefraction, position, rotation, vertices = [])
                {
                    super(position, rotation);
                    this.type = type;
                    this.indexOfRefraction = indexOfRefraction;
                    this.vertices = vertices;
                    this.isDragged = false;
                    this.dragOffset;
                    return this;
                }

                static get reflective()
                {
                    return 0;
                }

                static get refractive()
                {
                    return 1;
                }

                static get absorbing()
                {
                    return 2;
                }

                get isReflecting()
                {
                    return this.type === 0;
                }

                get isRefracting()
                {
                    return this.type === 1;
                }

                get isAbsorbing()
                {
                    return this.type === 2;
                }

                get isNotAbsorbing()
                {
                    return this.type !== 2;
                }

                incrementType(amount = 1)
                {
                    this.setType(this.type + amount);
                    return this;
                }

                decrementType(amount = 1)
                {
                    this.setType(this.type - Math.abs(amount));
                    return this;
                }

                setType(type)
                {
                    this.type = (type + 1) % 3;
                    return this;
                }

                getVertex(vertexdeterminant, absolute = false)
                {
                    let correctedVertexdeterminant = vertexdeterminant;

                    while(correctedVertexdeterminant < 0)
                    {
                        correctedVertexdeterminant += this.vertices.length;
                    }

                    let vertex = this.vertices[correctedVertexdeterminant % this.vertices.length];

                    if(absolute)
                    {
                        vertex = vertex.clone().rotateAroundPoint(pointOrigin, this.rotation).addTo(this.position);
                    }

                    return vertex;
                }

                getSide(sidedeterminant, absolute = false)
                {
                    return new Line(this.getVertex(sidedeterminant, absolute), this.getVertex(sidedeterminant + 1, absolute));
                }

                getExtremes(absolute = false)
                {
                    if(this.vertices.length === 0)
                    {
                        return false;
                    }

                    let leftMost;
                    let rightMost;
                    let upMost;
                    let downMost;

                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let vertex = this.getVertex(n, absolute);                    

                        if(leftMost === undefined || vertex.x <= leftMost.x)
                        {
                            leftMost = vertex;
                        }

                        if(rightMost === undefined || vertex.x >= rightMost.x)
                        {
                            rightMost = vertex;
                        }

                        if(upMost === undefined || vertex.y <= upMost.y)
                        {
                            upMost = vertex;
                        }

                        if(downMost === undefined || vertex.y >= downMost.y)
                        {
                            downMost = vertex;
                        }
                    }

                    return {
                        leftMost: leftMost,
                        rightMost: rightMost,
                        upMost: upMost,
                        downMost, downMost
                    };
                }

                pointInside(p, absolute)
                {
                    let pointOutside = this.getExtremes(absolute).leftMost.clone().subtractTo(new Point(1, 0));
                    let lineFromInsideToOutside = new Line(p, pointOutside);
                    let sum = 0;

                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let side = this.getSide(n, absolute);

                        if(intersectSegmentSegment(lineFromInsideToOutside, side))
                        {
                            sum++;
                        }
                    }

                    if(sum % 2 === 0)
                    {
                        return false;
                    }

                    return true;
                }

                findArea()
                {
                    if(this.vertices.length < 3)
                    {
                        return 0;
                    }

                    let sum = 0;

                    for(var n = 1; n <= this.vertices.length; n++)
                    {
                        sum += this.getVertex(n).x * this.getVertex(n + 1).y - this.getVertex(n + 1).x * this.getVertex(n).y;
                    }

                    return sum;
                }

                findCenter()
                {
                    let average = pointOrigin.clone();

                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let vertex = this.vertices[n];
                        average.addTo(vertex);
                    }

                    //average.scale(1 / this.vertices.length);
                    average.divideBy(this.vertices.length);

                    return average;
                }

                moveAnchorTo(p)
                {
                    this.translateVertices(this.position.clone().subtractTo(p));
                    this.position.setTo(p);
                }

                translateVertices(p)
                {
                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let vertex = this.vertices[n];
                        vertex.addTo(p);
                    }
                }

                scaleVertices(xs, ys = xs)
                {
                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let vertex = this.vertices[n];
                        vertex.scale(xs, ys);
                    }
                }

                subdivideVertices(vertexMultiplier = 2)
                {
                    for(var n = 0; n < this.vertices.length; n++)
                    {
                        let side = this.getSide(n);
                        let interpolations = [];

                        for(var m = 1; m < vertexMultiplier; m++)
                        {
                            this.vertices.splice(n + 1, 0, side.p1.clone().interpolateToPointLinear(side.p2, m / (vertexMultiplier + 1)));
                            n++;
                        }
                    }
                }

                smoothVertices(factor = 0.5, iterationsMultiplier = 1)
                {
                    if(this.vertices.length === 0)
                    {
                        return;
                    }

                    let initialArea = this.findArea();

                    for(var n = 0; n < Math.round(this.vertices.length * iterationsMultiplier); n++)
                    {
                        let previousVertex = this.getVertex(n - 1);
                        let vertex = this.getVertex(n);
                        let nextVertex = this.getVertex(n + 1);
                        let midPoint = previousVertex.clone().midPointTo(nextVertex);
                        vertex.interpolateToPointLinear(midPoint, factor);
                    }

                    let finalArea = this.findArea();
                    this.scaleVertices(Math.sqrt(initialArea / finalArea));
                }

                makeRectangle(width, height)
                {
                    let halfWidth = width / 2;
                    let halfHeight = height / 2;
                    let topLeftCorner = new Point(-halfWidth, -halfHeight);
                    let topRightCorner = new Point(halfWidth, -halfHeight);
                    let bottomRightCorner = new Point(halfWidth, halfHeight);
                    let bottomLeftCorner = new Point(-halfWidth, halfHeight);
                    this.vertices = [topLeftCorner, topRightCorner, bottomRightCorner, bottomLeftCorner];
                }

                makeCircle(radius, vertexCount)
                {
                    this.vertices = [];

                    for(var n = 0; n < vertexCount; n++)
                    {
                        let vertex = new Point();
                        vertex.addToPolar(radius, n / vertexCount * 2 * Math.PI);
                        this.vertices.push(vertex);
                    }
                }

                makeRegularPolygon(radius, vertexCount)
                {
                    this.vertices = [];

                    for(var n = 0; n < vertexCount; n++)
                    {
                        let angle = n / vertexCount * 2 * Math.PI;
                        this.vertices.push(new Point(radius * Math.cos(angle), radius * Math.sin(angle)));
                    }
                }

                makeBlob(averageRadius, maxRadiusDeviation, maxAngleDeviation, vertexCount)
                {
                    // 0 > maxAngleDeviation < 1
                    this.vertices = [];

                    for(var n = 0; n < vertexCount; n++)
                    {
                        let radius = clampMin(averageRadius + maxRadiusDeviation * averageRadius * 2 * (Math.random() - 0.5), 0);
                        let angle = (n + maxAngleDeviation * 2 * (Math.random() - 0.5)) / vertexCount * 2 * Math.PI;
                        this.vertices.push(new Point(radius * Math.cos(angle), radius * Math.sin(angle)));
                    }
                }
            }

            class Animation
            {
                constructor(keyframes, interpolationFunction, duration, isLooping = true)
                {
                    this.time = 0;
                    this.keyframes = keyframes;
                    this.interpolationFunction = interpolationFunction;
                    this.duration = duration;
                    this.isLooping = isLooping;
                    return this;
                }

                getValues()
                {
                    let lowKeyframe;

                    for(var n = 0; n < this.keyframes.length; n++)
                    {
                        let keyframe = this.keyframes[n];
                        if((lowKeyframe === undefined || keyframe.time >= lowKeyframe.time) && keyframe.time <= this.time)
                        {
                            lowKeyframe = keyframe;
                        }
                    }

                    let highKeyframe;

                    for(var n = 0; n < this.keyframes.length; n++)
                    {
                        let keyframe = this.keyframes[n];
                        if((highKeyframe === undefined || keyframe.time <= highKeyframe.time) && keyframe.time >= this.time)
                        {
                            highKeyframe = keyframe;
                        }
                    }

                    if(lowKeyframe === undefined)
                    {
                        return highKeyframe.values;
                    }

                    if(highKeyframe === undefined)
                    {
                        return lowKeyframe.values;
                    }

                    if(lowKeyframe === highKeyframe)
                    {
                        return lowKeyframe.values;
                    }

                    let mapped = map(this.time, lowKeyframe.time, highKeyframe.time, 0, 1);

                    if(Array.isArray(this.keyframes[0].values))
                    {
                        let values = [];

                        for(var n = 0; n < this.keyframes[0].values.length; n++)
                        {
                            values.push(this.interpolationFunction(lowKeyframe.values[n], highKeyframe.values[n], mapped));
                        }

                        return values;
                    }

                    else
                    {
                        return this.interpolationFunction(lowKeyframe.values, highKeyframe.values, mapped);
                    }
                }

                tick()
                {
                    this.time++;

                    if(this.isLooping)
                    {
                        while(this.time >= this.duration)
                        {
                            this.time -= this.duration;
                        }
                    }
                }
            }

            class Keyframe
            {
                constructor(time, values)
                {
                    this.time = time;
                    this.values = values;
                    return this;
                }
            }

            var request;
            const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
            const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
            var windowWidth = window.innerWidth;
            var windowHeight = window.innerHeight;
            const canvas = document.getElementById("canvas");
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const ctx = canvas.getContext("2d", {alpha: false});
            var glow = true;
            const pointOrigin = new Point(0, 0);
            var cameraPosition = pointOrigin.clone();
            var mousePosition = pointOrigin.clone();
            var mouseButtons = [false, false, false];
            var mouseMoveAction = "moveX";
            const keysPressed = [];
            var keysFired = false;
            const LASER_MAX_COLLISIONS = 50;
            const LASER_RANGE = 10000;
            var scene = new Scene(new Laser(new Point(100, 0), Math.PI / 10));
            scene.addMirror(new Mirror(Mirror.reflective, 1.33333, new Point(400, 50), 0, [new Point(0, 0), new Point(100, 0), new Point(100, 100)]));
            scene.addMirror(new Mirror(Mirror.refractive, 1.515, new Point(400, 50), 0, [new Point(0, 0), new Point(100, 0), new Point(100, 100)]));
            scene.addMirror(new Mirror(Mirror.refractive, 10, new Point(400, 50), 0, [new Point(0, 0), new Point(100, 0), new Point(100, 100)]));
            scene.mirrors[0].makeRectangle(300, 300);
            scene.mirrors[1].makeRectangle(300, 300);
            scene.mirrors[1].scaleVertices(2);
            scene.mirrors[2].makeBlob(500, 0.5, 0, 200);
            scene.mirrors[2].smoothVertices(0.5, 50);

            function render()
            {
                if(scene.draggedMirror !== false)
                {
                    if(mouseMoveAction === "move")
                    {
                        scene.draggedMirror.position.setTo(mousePosition).addTo(cameraPosition).subtractTo(scene.draggedMirror.dragOffset);
                    }

                    else if(mouseMoveAction === "moveX")
                    {
                        let y = scene.draggedMirror.position.y;
                        scene.draggedMirror.position.setTo(mousePosition).addTo(cameraPosition).subtractTo(scene.draggedMirror.dragOffset);
                        scene.draggedMirror.position.y = y;
                    }

                    else if(mouseMoveAction === "moveY")
                    {
                        let x = scene.draggedMirror.position.x;
                        scene.draggedMirror.position.setTo(mousePosition).addTo(cameraPosition).subtractTo(scene.draggedMirror.dragOffset);
                        scene.draggedMirror.position.x = x;
                    }
                    
                    else if(mouseMoveAction === "rotate")
                    {
                        let line = new Line(scene.draggedMirror.position, scene.draggedMirror.position.clone().subtractTo(scene.draggedMirror.dragOffset));
                        scene.draggedMirror.rotation = line.getAngle();
                    }
                }

                if(keysPressed.includes("ArrowLeft"))
                {
                    lasers[0].position.x -= 2;
                }

                if(keysPressed.includes("ArrowRight"))
                {
                    lasers[0].position.x += 2;
                }

                if(keysPressed.includes("ArrowUp"))
                {
                    lasers[0].position.y -= 2;
                }

                if(keysPressed.includes("ArrowDown"))
                {
                    lasers[0].position.y += 2;
                }

                if(keysPressed.includes("a"))
                {
                    lasers[0].rotation -= 0.02;
                }

                if(keysPressed.includes("d"))
                {
                    lasers[0].rotation += 0.02;
                }

                cameraPosition.interpolateToPointLinear(mousePosition.clone().scale(0.05), 0.05);

                scene.tick();

                ctx.fillStyle = "#000000";
                ctx.shadowBlur = 0;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.translate(canvasWidth / 2 - cameraPosition.x, canvasHeight / 2 - cameraPosition.y);
                
                ctx.lineWidth = 5;
                ctx.lineJoin = "round";

                let reflectingMirrors = [];
                let nonReflectingMirrors = [];

                for(var n = 0; n < scene.mirrors.length; n++)
                {
                    let mirror = scene.mirrors[n];

                    if(mirror.isReflecting)
                    {
                        reflectingMirrors.push(mirror);
                    }

                    else
                    {
                        nonReflectingMirrors.push(mirror);
                    }
                }

                let mirrors = scene.mirrors;

                for(var n = 0; n < 3; n++)
                {
                    let selectedMirrors;

                    if(n === 0)
                    {
                        selectedMirrors = mirrors.filter(function(mirror)
                        {
                            return !mirror.isNotAbsorbing;
                        });

                        ctx.strokeStyle = "#222222";
                    }

                    else
                    {
                        if(n === 1)
                        {
                            selectedMirrors = mirrors.filter(function(mirror)
                            {
                                return !mirror.isDragged && mirror.isNotAbsorbing;
                            });

                            ctx.strokeStyle = "#ff0000";
                            ctx.shadowBlur = getGlow(20);
                        }

                        else
                        {
                            selectedMirrors = mirrors.filter(function(mirror)
                            {
                                return mirror.isDragged && mirror.isNotAbsorbing;
                            });

                            ctx.strokeStyle = "#00d0ff";
                            ctx.shadowBlur = getGlow(40);
                        }

                        ctx.shadowColor = ctx.strokeStyle;
                    }

                    for(var m = 0; m < selectedMirrors.length; m++)
                    {
                        let mirror = selectedMirrors[m];
                        let vertices = mirror.vertices;
                        ctx.save();
                        ctx.translate(mirror.position.x, mirror.position.y);
                        ctx.rotate(mirror.rotation);
                        ctx.beginPath();
                        ctx.moveTo(vertices[0].x, vertices[0].y);

                        for(var v = 1; v < vertices.length; v++)
                        {
                            let vertex = vertices[v];
                            ctx.lineTo(vertex.x, vertex.y);
                        }

                        ctx.closePath();
                        ctx.stroke();
                        ctx.restore();
                    }
                }

                ctx.lineWidth = 3;
                ctx.shadowBlur = getGlow(20);

                let lasersCollisions = scene.getLaserCollisions();

                for(var n = 0; n < lasersCollisions.length; n++)
                {
                    let laser = scene.lasers[n];
                    let laserCollisions = lasersCollisions[n];

                    ctx.strokeStyle = "hsl(120, 100%, 50%)";
                    ctx.shadowColor = ctx.strokeStyle;
                    ctx.beginPath();
                    ctx.moveTo(laser.position.x, laser.position.y);
                    
                    for(var m = 0; m < laserCollisions.length; m++)
                    {
                        let laserCollision = laserCollisions[m];
                        ctx.lineTo(laserCollision.x, laserCollision.y);
                    }

                    ctx.stroke();
                }

                ctx.fillStyle = "#ffffff";
                ctx.shadowBlur = 0;

                ctx.resetTransform();
                ctx.save();
                ctx.translate(mousePosition.x + canvasWidth / 2, mousePosition.y + canvasHeight / 2);
                ctx.beginPath();

                if(scene.draggedMirror === false)
                {
                    ctx.moveTo(0, 0);
                    ctx.lineTo(10, 30);
                    ctx.lineTo(20, 20);
                }

                else
                {
                    ctx.moveTo(-1, -1);

                    for(var n = 0; n < 4; n++)
                    {
                        ctx.lineTo(-1, -10);
                        ctx.lineTo(-5, -10);
                        ctx.lineTo(0, -17);
                        ctx.lineTo(5, -10);
                        ctx.lineTo(1, -10);
                        ctx.lineTo(1, -1);
                        ctx.rotate(Math.PI / 2);
                    }
                }

                ctx.fill();
                ctx.restore();

                request = requestAnimationFrame(render);
            }

            resize();
            window.onresize = resize;
            window.onmousedown = mousedown;
            window.onmouseup = mouseup;
            window.onmousemove = mousemove;
            window.onwheel = wheel;
            window.onkeydown = keydown;
            window.onkeyup = keyup;
            window.onload = function()
            {
                request = requestAnimationFrame(render);
            }
            window.oncontextmenu = function(event) { event.preventDefault(); };

            function resize()
            {
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                
                if(windowWidth / windowHeight > canvasWidth / canvasHeight)
                {
                    canvas.style.width = `${(windowHeight / windowWidth) * (canvasWidth / canvasHeight) * 100}%`;
                    canvas.style.height = "100%";
                }
                
                else
                {
                    canvas.style.width = "100%";
                    canvas.style.height = `${(windowWidth / windowHeight) * (canvasHeight / canvasWidth) * 100}%`;
                }
            }

            function mousedown(event)
            {
                if(!event)
                {
                    event = window.event;
                }

                mouseButtons[event.button] = true;
                let point = mousePosition.clone().addTo(cameraPosition);
                let closest = scene.getClosestObjectToPoint(point, scene.getMirrorsWithPointInside(point));

                if(closest !== false)
                {
                    let mirror = closest.object;
                    mirror.isDragged = true;
                    mirror.isHovered = true;
                    mirror.dragOffset = point.subtractTo(mirror.position);
                }
            }

            function mouseup(event)
            {
                if(!event)
                {
                    event = window.event;
                }

                mouseButtons[event.button] = false;
                scene.draggedMirror.isDragged = false;
            }

            function mousemove(event)
            {
                if(!event)
                {
                    event = window.event;
                }

                let rect = canvas.getBoundingClientRect();
                mousePosition.setTo(new Point(map(event.clientX, rect.left, windowWidth - rect.left, -canvasWidth / 2, canvasWidth / 2), map(event.clientY, rect.top, windowHeight - rect.top, -canvasHeight / 2, canvasHeight / 2)));
            }

            function wheel(event)
            {
                if(!event)
                {
                    event = window.event;
                }

                var delta = Math.sign(event.deltaY);
                
                if(scene.draggedMirror !== false)
                {
                    if(mouseButtons[0])
                    {
                        scene.draggedMirror.rotation += delta / 10;
                    }

                    if(mouseButtons[2])
                    {
                        scene.draggedMirror.scaleVertices(map(delta, -1, 1, 1.1, 0.9));
                    }
                }
            }

            function keydown(event)
            {
                if(!event)
                {
                    event = window.event;
                }
                
                var eventKey = event.key;
                
                if(keysPressed.includes(eventKey) === false)
                {
                    keysPressed.push(eventKey);
                }

                if(!keysFired)
                {
                    keysFired = true;

                    if(eventKey.toUpperCase() === "M")
                    {
                        mouseMoveAction = "move";
                    }

                    else if(eventKey.toUpperCase() === "X")
                    {
                        mouseMoveAction = "moveX";
                    }

                    else if(eventKey.toUpperCase() === "Y")
                    {
                        mouseMoveAction = "moveY";
                    }

                    else if(eventKey.toUpperCase() === "G")
                    {
                        glow = !glow;
                    }

                    else if(eventKey.toUpperCase() === "R")
                    {
                        if(scene.draggedMirror !== false)
                        {
                            scene.draggedMirror.incrementType();
                        }
                    }
                }
            }
            
            function keyup(event)
            {
                if(!event)
                {
                    event = window.event;
                }
                
                var eventKey = event.key;
                
                keysPressed.splice(keysPressed.indexOf(eventKey), 1);
                keysFired = false;
            }

            function getGlow(shadowBlur)
            {
                if(glow)
                {
                    return shadowBlur;
                }

                return 0;
            }

            function getPropertiesOfObjects(objects, property)
            {
                let properties = [];

                for(var n = 0; n < objects.length; n++)
                {
                    properties.push(objects[n][property]);
                }

                return properties;
            }

            function minimum(values)
            {
                let min;

                for(var n = 0; n < values.length; n++)
                {
                    let value = values[n];

                    if(min === undefined || value < min)
                    {
                        min = value;
                    }
                }

                return min;
            }

            function maximum(values)
            {
                let max;

                for(var n = 0; n < values.length; n++)
                {
                    let value = values[n];

                    if(max === undefined || value > max)
                    {
                        max = value;
                    }
                }

                return max;
            }

            function average(values)
            {
                let sum = 0;

                for(var n = 0; n < values.length; n++)
                {
                    sum += values[n];
                }

                return sum / values.length;
            }

            function randomInteger(min = 0, max = 1)
            {
                return Math.floor(randomFloat(min, max + 1));
            }

            function randomFloat(min = 0, max = 1)
            {
                return Math.random() * (max - min) + min;
            }

            function clampMin(num, min)
            {
                return Math.max(num, min)
            }
            
            function clampMax(num, max)
            {
                return Math.min(num, max);
            }
            
            function clamp(num, min, max)
            {
                return Math.min(Math.max(num, min), max);
            }

            function map(value, start1, stop1, start2, stop2)
            {
                return ((value - start1) / (stop1 - start1)) * (stop2 - start2) + start2;
            }

            function distance(p1, p2 = pointOrigin)
            {
                return Math.hypot(p1.x - p2.x, p1.y - p2.y);
            }
            
            function distanceSquared(p1, p2)
            {
                return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
            }
            
            function distanceManhattan(p1, p2)
            {
                return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
            }

            function interpolateLinear(startingValue, endingValue, t)
            {
                return (startingValue + (endingValue - startingValue) * t);
            }

            function interpolateQuadratic(startingValue, endingValue, t)
            {
                return interpolateLinear(startingValue, endingValue, t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);
            }

            function interpolateElastic(startingValue, endingValue, t)
            {
                const c5 = (2 * Math.PI) / 4.5;
                return interpolateLinear(startingValue, endingValue, t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5)) / 2 + 1);
            }

            function calculateAngleDifference(a1, a2)
            {
                var difference = a2 - a1;
                while(difference < -Math.PI)
                    difference += 2 * Math.PI;
                while(difference > Math.PI)
                    difference -= 2 * Math.PI;
                return difference;
            }

            function intersectSegmentSegment(line1, line2)
            {
                return intersectionSegmentSegment(line1, line2) !== false;
            }

            function intersectionLineLine(line1, line2)
            {
                return intersectionStraightStraight(line1, line2, function(ua, ub)
                {
                    return true;
                });
            }

            function intersectionLineSegment(line1, line2)
            {
                return intersectionStraightStraight(line1, line2, function(ua, ub)
                {
                    if(ub < 0 || ub > 1)
                    {
                        return false;
                    }

                    return true;
                });
            }

            function intersectionSegmentSegment(line1, line2)
            {
                return intersectionStraightStraight(line1, line2, function(ua, ub)
                {
                    if(ua < 0 || ua > 1 || ub < 0 || ub > 1)
                    {
                        return false;
                    }

                    return true;
                });
            }

            function intersectionSegmentRay(line1, line2)
            {
                return intersectionStraightStraight(line1, line2, function(ua, ub)
                {
                    if(ua < 0 || ua > 1 || ub < 0)
                    {
                        return false;
                    }

                    return true;
                });
            }

            function intersectionStraightStraight(line1, line2, eliminationFunction)
            {
                let x1 = line1.p1.x;
                let y1 = line1.p1.y;
                let x2 = line1.p2.x;
                let y2 = line1.p2.y;
                let x3 = line2.p1.x;
                let y3 = line2.p1.y;
                let x4 = line2.p2.x;
                let y4 = line2.p2.y;

                if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4))
                {
                    return false
                }

                denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))

                if (denominator === 0)
                {
                    return false
                }

                let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator
                let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator

                if(eliminationFunction(ua, ub) === false)
                {
                    return false;
                }

                let x = x1 + ua * (x2 - x1);
                let y = y1 + ua * (y2 - y1);

                return new Point(x, y);
            }

            function intersectionSegmentCircle(line, circle)
            {
                var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;
                v1 = {};
                v2 = {};
                v1.x = line.p2.x - line.p1.x;
                v1.y = line.p2.y - line.p1.y;
                v2.x = line.p1.x - circle.position.x;
                v2.y = line.p1.y - circle.position.y;
                b = (v1.x * v2.x + v1.y * v2.y);
                c = 2 * (v1.x * v1.x + v1.y * v1.y);
                b *= -2;
                d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));
                if(isNaN(d))
                {
                    return [];
                }
                u1 = (b - d) / c;
                u2 = (b + d) / c;    
                retP1 = {};
                retP2 = {}  
                ret = [];
                if(u1 <= 1 && u1 >= 0)
                {
                    retP1 = new Point(line.p1.x + v1.x * u1, line.p1.y + v1.y * u1);
                    ret[0] = retP1;
                }
                if(u2 <= 1 && u2 >= 0)
                {
                    retP2 = new Point(line.p1.x + v1.x * u2, line.p1.y + v1.y * u2);
                    ret[ret.length] = retP2;
                }       
                return ret;
            }
            
        </script>
    </body>
</html>